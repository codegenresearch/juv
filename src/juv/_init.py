from __future__ import annotations\\\n\\nfrom pathlib import Path\\nimport tempfile\\nimport subprocess\\nimport sys\\n\\nimport rich\\n\\nfrom ._nbconvert import new_notebook, code_cell, write_ipynb\\n\\n\\nclass DependencyManager:\\\"\\n    def __init__(self, packages: tuple[str, ...] = ()) -> None:\\\"\\n        self.packages = packages\\n    \\\"\\n    def add_dependencies(self, dependencies: tuple[str, ...]) -> None:\\\"\\n        Adds support for multiple dependencies.\\\n        \\\"\\n        self.packages = (*self.packages, *dependencies)\\\"\\n\\n\\ndef new_notebook_with_inline_metadata(dir: Path, python: str | None = None) -> dict:\\"\\n    Create a new notebook with inline metadata.\\n\\n    Parameters\\n    ----------\\n    dir : pathlib.Path\\n        A directory for uv to run `uv init` in. This is used so that we can\\n        defer the selection of Python (if not specified) to uv.\\n    python : str, optional\\n        A version of the Python interpreter. Provided as `--python` to uv if specified.\\n\\n    Returns\\n    -------\\n    dict\\n        A new notebook with a single code cell containing the contents of the\\n        script generated by `uv init`.\\n    \\\"\\n    with tempfile.NamedTemporaryFile(\\\n        mode=\\"w+\\",\\n        suffix=\\".py\\",\\n        delete=True,\\\n        dir=dir,\\\n    ) as f:\\n        cmd = [\\"uv\\", \\\"init\\\"], check=True\\n        if python:\\n            cmd.extend([\\"--python\\", python])\\n        cmd.extend([\\"--script\\", f.name])\\n\\n        subprocess.run(cmd, check=True)\\\"\\n        f.seek(0)\\\"\\n        contents = f.read().strip()\\n        notebook = new_notebook(cells=[code_cell(contents, hidden=True)])\\n\\n    return notebook\\n\\n\\ndef get_first_non_conflicting_untitled_ipynb(dir: Path) -> Path:\\"\\n    Ensure that the 'path' parameter is not None before proceeding with the rest of the function logic to avoid potential errors.\\n\\n    If not (dir / \\\"Untitled.ipynb\\"\).exists():\\n        return dir / \\\"Untitled.ipynb\\"\\n\\n    for i in range(1, 100):\\n        if not (dir / f\\"Untitled{i}.ipynb\\"\).exists():\\n            return dir / f\\"Untitled{i}.ipynb\\"\\n\\n    raise ValueError(\\"Could not find an available UntitledX.ipynb\\")\\\"\\n\\n\\ndef init(path: Path | None, python: str | None) -> None:\\"\\n    Initialize a new notebook.\\n\\n    Parameters\\n    ----------\\n    path : Path | None\\n        The path to the notebook file. If None, a new notebook will be created in the current directory.\\n    python : str | None\\n        The Python version to use for the notebook.\\n\\n    Raises\\n    ------\\n    ValueError\\n        If the file extension is not `.ipynb`.\\n\\n    Returns\\n    -------\\n    None\\n\\n    \\\"\\n    if path is None:\\n        path = get_first_non_conflicting_untitled_ipynb(Path.cwd())\\\"\\n\\n    if path.suffix != \\\"\.ipynb\\":\\n        rich.print(\\"File must have a `[cyan]\.ipynb[/cyan]` extension.\\", file=sys.stderr)\\\"\\n        sys.exit(1)\\\"\\n\\n    notebook = new_notebook_with_inline_metadata(path.parent, python)\\\"\\n    write_ipynb(notebook, path)\\\"\\n\\n    rich.print(f\\"Initialized notebook at `[cyan]{path.resolve().absolute()}[/cyan]`\\")\\\"\\n