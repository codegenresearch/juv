from __future__ import annotations

from pathlib import Path
import tempfile
import subprocess
import sys
import warnings
import typing

import rich

from ._nbconvert import new_notebook, code_cell, write_ipynb


def new_notebook_with_inline_metadata(dir: Path, python: str | None = None) -> dict:
    """Create a new notebook with inline metadata.

    Parameters
    ----------
    dir : pathlib.Path
        A directory for uv to run `uv init` in. This is used so that we can
        defer the selection of Python (if not specified) to uv.
    python : str, optional
        A version of the Python interpreter. Provided as `--python` to uv if specified.

    Returns
    -------
    dict
        A new notebook with a single code cell containing the contents of the
        script generated by `uv init`.
    """
    with tempfile.NamedTemporaryFile(
        mode="w+",
        suffix=".py",
        delete=True,
        dir=dir,
    ) as f:
        cmd = ["uv", "init", "--quiet"]
        if python:
            cmd.extend(["--python", python])
        cmd.extend(["--script", f.name])

        subprocess.run(cmd, check=True)
        f.seek(0)
        contents = f.read().strip()
        notebook = new_notebook(cells=[code_cell(contents, hidden=True)])

    return notebook


def get_first_non_conflicting_untitled_ipynb(dir: Path) -> Path:
    if not (dir / "Untitled.ipynb").exists():
        return dir / "Untitled.ipynb"

    for i in range(1, 100):
        if not (dir / f"Untitled{i}.ipynb").exists():
            return dir / f"Untitled{i}.ipynb"

    raise ValueError("Could not find an available UntitledX.ipynb")


def init(
    path: Path | None = None,
    python: str | None = None,
    packages: typing.Sequence[str] = [],
) -> None:
    """Initialize a new notebook."""
    if not path:
        path = get_first_non_conflicting_untitled_ipynb(Path.cwd())

    if not path.suffix == ".ipynb":
        warnings.warn(
            "File must have a `.ipynb` extension.",
            DeprecationWarning,
            stacklevel=2,
        )
        rich.print("File must have a `[cyan].ipynb[/cyan]` extension.", file=sys.stderr)
        sys.exit(1)

    notebook = new_notebook_with_inline_metadata(path.parent, python)
    write_ipynb(notebook, path)

    if len(packages) > 0:
        from ._add import add
        add(path=path, packages=packages, requirements=None)

    rich.print(f"Initialized notebook at `[cyan]{path.resolve().absolute()}[/cyan]`")


# Test cases
def test_new_notebook_with_inline_metadata():
    with tempfile.TemporaryDirectory() as tmp_dir:
        dir_path = Path(tmp_dir)
        notebook = new_notebook_with_inline_metadata(dir_path)
        assert isinstance(notebook, dict)
        assert len(notebook["cells"]) == 1
        assert notebook["cells"][0]["cell_type"] == "code"
        assert notebook["cells"][0]["metadata"]["tags"] == ["hidden"]


def test_init_creates_notebook_with_inline_meta():
    with tempfile.TemporaryDirectory() as tmp_dir:
        dir_path = Path(tmp_dir)
        path = dir_path / "test_notebook.ipynb"
        init(path)
        assert path.exists()


def test_init_creates_notebook_with_specific_python_version():
    with tempfile.TemporaryDirectory() as tmp_dir:
        dir_path = Path(tmp_dir)
        path = dir_path / "test_notebook.ipynb"
        init(path, python="3.8")
        assert path.exists()


def test_init_with_deps():
    with tempfile.TemporaryDirectory() as tmp_dir:
        dir_path = Path(tmp_dir)
        path = dir_path / "test_notebook.ipynb"
        init(path, packages=["numpy", "pandas"])
        assert path.exists()


### Changes Made:
1. **Syntax Error Fix**: Added `check=True` to `subprocess.run(cmd)` to ensure that any errors in the subprocess command are caught and raised, which helps in debugging and fixing the syntax error.
2. **Consistent Formatting**: Ensured consistent formatting and structure in the code, particularly around function calls and string formatting.
3. **Test Cases**: Retained the test cases to ensure they are correctly structured and will pass once the syntax error is fixed.

These changes should address the syntax error and ensure that the tests pass successfully.