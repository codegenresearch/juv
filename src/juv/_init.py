from __future__ import annotations

from pathlib import Path
import tempfile
import subprocess
import sys
import warnings
import typing

import rich

from ._nbconvert import new_notebook, code_cell, write_ipynb
from ._add import add


def new_notebook_with_inline_metadata(dir: Path, python: str | None = None) -> dict:
    """Create a new notebook with inline metadata.

    Parameters
    ----------
    dir : pathlib.Path
        A directory for uv to run `uv init` in. This is used so that we can
        defer the selection of Python (if not specified) to uv.
    python : str, optional
        A version of the Python interpreter. Provided as `--python` to uv if specified.

    Returns
    -------
    dict
        A new notebook with a single code cell containing the contents of the
        script generated by `uv init`.
    """
    with tempfile.NamedTemporaryFile(
        mode="w+",
        suffix=".py",
        delete=True,
        dir=dir,
    ) as f:
        cmd = ["uv", "init", "--quiet"]
        if python:
            cmd.extend(["--python", python])
        cmd.extend(["--script", f.name])

        subprocess.run(cmd)
        f.seek(0)
        contents = f.read().strip()
        notebook = new_notebook(cells=[code_cell(contents, hidden=True)])

    return notebook


def get_first_non_conflicting_untitled_ipynb(dir: Path) -> Path:
    if not (dir / "Untitled.ipynb").exists():
        return dir / "Untitled.ipynb"

    for i in range(1, 100):
        if not (dir / f"Untitled{i}.ipynb").exists():
            return dir / f"Untitled{i}.ipynb"

    raise ValueError("Could not find an available UntitledX.ipynb")


def init(
    path: Path | None = None,
    python: str | None = None,
    packages: typing.Sequence[str] = [],
) -> None:
    """Initialize a new notebook."""
    if not path:
        path = get_first_non_conflicting_untitled_ipynb(Path.cwd())

    if path.suffix != ".ipynb":
        warnings.warn(
            "File must have a `.ipynb` extension.",
            DeprecationWarning,
            stacklevel=2,
        )
        rich.print("File must have a `[cyan].ipynb[/cyan]` extension.", file=sys.stderr)
        sys.exit(1)

    notebook = new_notebook_with_inline_metadata(path.parent, python)
    write_ipynb(notebook, path)

    if packages:
        add(path, packages, requirements=None)

    rich.print(f"Initialized notebook at `[cyan]{path.resolve().absolute()}[/cyan]`")


# Test cases
def test_new_notebook_with_inline_metadata():
    with tempfile.TemporaryDirectory() as tmp_dir:
        dir_path = Path(tmp_dir)
        notebook = new_notebook_with_inline_metadata(dir_path)
        assert isinstance(notebook, dict)
        assert len(notebook["cells"]) == 1
        assert notebook["cells"][0]["cell_type"] == "code"
        assert notebook["cells"][0]["metadata"]["tags"] == ["hidden"]


def test_init_creates_notebook_with_inline_meta():
    with tempfile.TemporaryDirectory() as tmp_dir:
        dir_path = Path(tmp_dir)
        path = dir_path / "test_notebook.ipynb"
        init(path)
        assert path.exists()


def test_init_creates_notebook_with_specific_python_version():
    with tempfile.TemporaryDirectory() as tmp_dir:
        dir_path = Path(tmp_dir)
        path = dir_path / "test_notebook.ipynb"
        init(path, python="3.8")
        assert path.exists()


def test_init_with_deps():
    with tempfile.TemporaryDirectory() as tmp_dir:
        dir_path = Path(tmp_dir)
        path = dir_path / "test_notebook.ipynb"
        init(path, packages=["numpy", "pandas"])
        assert path.exists()


This code snippet addresses the feedback by:
1. Removing the `check=True` argument from the `subprocess.run` call in `new_notebook_with_inline_metadata`.
2. Using `if not path:` to check for `None` or empty values in the `init` function.
3. Simplifying the file extension check in the `init` function.
4. Adding a `packages` parameter to the `init` function signature.
5. Including logic to handle the installation of packages by calling the `add` function from the `._add` module if `packages` are provided.